## 一. 关键字：

### 1.**extern**/volatile/mutable关键字

**extern**

* 与“C”连用，用作链接指定，解决名字匹配问题（在C++程序中调用被C编译器编译后的函数，为什么要加extern”C”？）

  ​    C++语言支持函数重载，C语言不支持。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为：void foo(int x,inty)。该函数被C编译后在库中的名称为_foo，而C++编译器则会产生_foo_int_int之类的名称。通过这种定义来告诉编译器：请按照C的方法来对我这个函数进行编译。

* 置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。不过extern只是声明，而不是定义，也就是说extern并不分配空间。而这个查找的过程是在链接的过程中进行的，因此编译阶段虽然找不到该变量或函数，但是也不会报错。

**volatile**

volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。

### 2.static关键字的作用

static的意思是静态的，可以用来修饰变量，函数和类成员。

* 变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。
* 函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。
* 类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被**static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。**

​    【note】静态成员函数要访问非静态成员时，要通过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。静态局部变量仅在第一次调用时定义。

### 3.const关键字的作用

* 变量：说明是一个常量，值不可修改；
* const 修饰指针变量有以下三种情况。
  - const 修饰指针指向的内容，则内容为不可变量。
  -  const 修饰指针，则指针为不可变量。
  - const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。

* 成员函数：表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数。

* 自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。

  并且对于一般的 int、double 等内置类型，我们不采用引用的传递方式。

  ```c++
  #include<iostream>
   
  using namespace std;
   
  class Test
  {
  public:
      Test(){}
      Test(int _m):_cm(_m){}
      int get_cm()const
      {
         return _cm;
      }
   
  private:
      int _cm;
  };
   
   
   
  void Cmf(const Test& _tt)//避免构造临时对象调用构造函数
  {
      cout<<_tt.get_cm();
  }
   
  int main(void)
  {
      Test t(8);
      Cmf(t);
      system("pause");
      return 0;
  }
  ```

**static和const可以同时修饰成员函数吗**

const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。

### 3.inline关键字，和宏定义有什么区别

inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。

1、内联函数在编译时展开，而宏在预编译时展开

2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。

3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。

4、宏不是函数，而inline是函数

5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。

6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。

7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。

### 4.define 和const的联系与区别（编译阶段、安全性、内存占用等）

  联系：它们都是定义常量的一种方法。

  区别：

* define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。
* define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。
* define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。
* const可以定义函数而define不可以。

### 5.strlen()和sizeof()的区别

- sizeof是一个单目运算符，以字节形式给出其操作数的存储大小，操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型决定。它的计算发生在编译时，所以可以被当作常量表达式使用，且会忽略括号内的各种运算，如“sizeof(a++)"中的++不执行。

- strlen()是函数，用于计算字符数组的字符数，以’\0'为结束标志，且不将'\0'计算在字符数内。

区别：

1. 数组做 **sizeof** 的参数不退化，传递给 **strlen** 就退化为指针了。

2. **sizeof** 计算发生在编译时，是类型或是变量的长度，这就是 **sizeof(x)** 可以用来定义数组维数的原因；

   **strlen** 的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小。

```C++
char str[20]="0123456789";
int a=strlen(str); // a=10;字符串长度
int b=sizeof(str); // 而 b=20;类型占用内存大小
```

3. 处理静态数组和指针的差别

   ```c++
   char str[20]="0123456789";
   int a=strlen(str);         // a=10; >>>> strlen 计算字符串的长度，以结束符 0x00 为字符串结束。
   int b=sizeof(str);         // 而 b=20; >>>> sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。  
   
   char* ss = "0123456789";
   sizeof(ss);//结果 4 ＝＝＝》ss 是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是 4。
   sizeof(*ss);// 结果 1 ＝＝＝》*ss 是第一个字符 其实就是获得了字符串的第一位 '0' 所占的内存空间，是 char 类型的，占了 1 位
   strlen(ss)= 10;// ＝＝＝》 如果要获得这个字符串的长度，则一定要使用 strlen。strlen 用来求字符串的长度；而 sizeof 是用来求指定变量或者变量类型等所占内存大小。
   ```

## 二. 内存管理

### 1.内存模型

| 堆                 | 由程序员手动分配和释放，分配方式类似链表。由malloc或new来分配，free或delete来释放。若程序员未释放，结束时由系统释放。 |
| ------------------ | ------------------------------------------------------------ |
| 栈                 | 由编译器自动分配和释放的，存放函数的参数值、局部变量的值等。操作方式类似stack。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 |
| 全局（静态）存储区 | 存放全局变量和静态变量。包括DATA段（全局初始化区）与BSS段（全局未初始化区）。  DATA段：初始化的全局变量和静态变量；    BSS段：未初始化的全局变量和静态变量。BSS段的特点是程序执行之前会自动清0，所以未初始的全局变量与静态变量在程序执行之前已经成0了。程序结束后由系统释放。 |
| 文字常量区         | 常量字符串存在这里。程序结束后由系统释放。                   |
| 程序代码区         | 存放函数体的二进制代码。                                     |

```c++
//main.cpp
int a = 0;                     //全局初始化区
char *p1;                      //全局未初始化区

int main()
{
  int b;                       //栈区
  char s[] = "abc";            //栈区
  char *p2;                    //栈区
  char *p3 = "123456";         //123456在常量区，指针p3在栈上。
  static int c =0；            //全局（静态）初始化区
  p1 = (char *)malloc(10);
  p2 = (char *)malloc(20);
  //分配得来得10和20字节的区域就在堆区。
  strcpy(p1, "123456");      
  //123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
```

.哪些区域是无法通过指针访问的？

### 2.堆和栈的区别，为什么要分成堆和栈？

* 从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。

* 堆空间因为会有频繁的分配释放操作，会产生内存碎片

* 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小

  栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

### 3.为什么堆会产生碎片，如何处理？

* 静态分配和动态分配

  静态分配在程序编译链接时分配的大小和使用寿命就已经确定，动态分配使得操作系统提供给进程在运行时申请和释放任意大小内存的功能。

  内存碎片是指系统中所有不可用的空闲内存，这些空闲内存以小且不连续的方式出现在不同的位置，因此动态分配内存的算法无法使用这些空闲内存。

* 内存碎片产生的原因：

  1. 动态内存分配引起

  内部碎片的产生：因为所有的内存分配必须起始于可被 4、8 或 16 整除（视处理器体系结构而定）的地址或者因为MMU的分页机制的限制，决定内存分配算法仅能把预定大小的内存块分配给客户。假设当某个客户请求一个 43 字节的内存块时，因为没有适合大小的内存，所以它可能会获得 44字节、48字节等稍大一点的字节，因此由所需大小四舍五入而产生的多余空间就叫内部碎片。

   外部碎片的产生： 频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。

  2. 系统回收机制引起的

     内存碎片是一个系统问题，反复的malloc和 free，而free后的内存又不能马上被系统回收利用。这个与系统对内存的回收机制有关。
  
  被free回收的内存是立即返还给操作系统吗？为什么？
  
  被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

* #####  如何减少频繁分配内存（malloc或者new）造成的内存碎片?

  ​	内存池（Memory Pool)是一种内存分配方式。通常我们习惯直接使用new、malloc等申请内存呢，这样做的缺点在于：由于所申请的内存块的大小不定，当频繁使用时会造成大量的内存碎片进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。

### 4.内存溢出和内存泄漏（原因，分析）

* 动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。

造成内存泄漏的几种原因：

1）类的构造函数和析构函数中new和delete没有配套

2）在释放对象数组时没有使用delete\[\]，使用了delete

3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露

避免方法：

1. malloc/free要配套
2. 使用智能指针；
3. 将基类的析构函数设为虚函数。

* 内存溢出：是指**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。

内存溢出的应对：

1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
2.检查代码中是否有死循环或递归调用。
3.检查是否有大循环重复产生新对象实体。

### 5.多线程中堆和栈是如何分配的？

在多线程环境下，每个线程拥有一个**栈**和一个程序**计数器**。栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程**私有**的资源。其他的资源（比如**堆**、地址空间、全局变量）是由**同一个进程内的多个线程共享**。

### 6.指针和引用的区别

* 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作
* 指针可以有多级，引用只有一级
* 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改
* 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小
* 指针可以为空，引用不可以。

### 7.传值、传引用和传指针的比较（从作用到优缺点）

1.使用场景：

* 需要**返回函数内局部变量的内存**的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会**内存泄漏**。而返回局部变量的引用是没有意义的
* 对栈空间大小比较敏感（比如递归）的时候使用引用。使用**引用传递不需要创建临时变量，开销要更小**
* **类对象**作为参数传递的时候**使用引用**，这是C++类对象传递的标准方式

2. 引用传参的优缺点

   **优点：**

   1）在函数内部可以对此参数进行修改

   2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）

   如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。

   用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。

   但是有以下的**限制**：

   1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁

   2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak

   3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 

### 8.结构体内存对齐方式

因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。

对齐规则：

* 第一个成员在与结构体变量偏移量为0的地址
* 整体空间是占用空间最大的成员所占字节数的整数倍
* 内存按结构体成员的先后顺序排列，当排到该成员时，其前面已摆放空间的大小必须是该成员类型大小的整数倍，如果不够则补齐。
* 在Linux+gcc环境下，某成员类型所占字节数超过4，如double是8，则前面已摆放空间是4的倍数即可。

#### struct和union的区别

1：共用体和结构体都是由多个不同的数据类型成员组成， 但在任何同一时刻，共用体只存放一个被选中的成员，而结构体则存放所有的成员变量。

2：对于共用体的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于结构体的不同成员赋值是互不影响的。

### 9.new和delete是如何实现的，new 与 malloc的异同处

在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。

new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名

### 10.既然有了malloc/free，C++中为什么还需要new/delete呢？

https://blog.csdn.net/leikun153/article/details/80612130

* malloc/free和new/delete都是用来申请内存和回收内存的。
* 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。

### 11.delete和delete\[\]的区别

* delete只会调用一次析构函数，而delete\[\]会调用每个成员的析构函数
* 用new分配的内存用delete释放，用new\[\]分配的内存用delete\[\]释放

### 12.可执行文件的内存结构

13.空悬指针和野指针

* 空悬指针，又叫迷途指针。即指向一块曾经保存数据但现在已经无效的内存的指针。避免的方法是在指针即将离开其作用域之前释放掉它所关联的内存。

  ```c++
  {
     char *dp = NULL;
     /* ... */
     {
         char c;
         dp = &c;
     } /* c falls out of scope */
       /* dp is now a dangling pointer */
  }
  
  int *func(void)
  {
      int num = 1234;
      /* ... */
      return &num;
  }//调用 func 后，从该指针暂时能读取到正确的值（1234），但是再次调用函数后将会重写栈为 num 分配的值，再从该指针读取的值就不正确了。如果必须要返回一个指向 num 的指针，num 的作用域必须大于这个函数——它也许被声明为 static。
  ```

* 野指针：野指针的产生是由于在首次使用之前没有进行必要的初始化。因此，严格地说，在编程语言中的所有未初始化的指针都是野指针。

  ```c++
  int f(int i)
  {
      char *dp;    /* dp is a wild pointer */
      static char *scp;  /* scp 不是一个野指针：静态变量一开始被初始化为0，从最后一次调用后保持着它的值。如果没有注释，使用这个特性也许被视为不良风格。 */
  }
  ```

  

## 三. 继承和多态

### 1.重载和重写

* **函数重载**只会发生在同作用域中（或同一个类中），函数名称相同，但参数类型或参数个数不同。函数**重载不能通过函数的返回类型来区分**，因为在函数返回之前我们并不知道函数的返回类型。
* **函数重写**是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。**虚函数**

### 2.编译时多态的实现

C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。

* 虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.

  详见：[C++虚函数表的剖析](https://blog.csdn.net/lihao21/article/details/50688337)

C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。

编译器处理虚函数的方法是：
如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。
	为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。

[多重继承和多继承的虚函数表](https://blog.csdn.net/qq_36359022/article/details/81870219)

### 3.为什么父类的析构函数要定义为虚函数

存在继承时，基类的析构函数必须是虚函数。这是为了应对基类的指针指向派生类对象，需要用基类的指针删除派生类对象的情况。

* 每个析构函数只负责清除自己的成员；

* 当基类的指针指向派生类成员时，如果析构函数不是虚函数，删除基类指针就会只调用基类的析构函数，派生类对象析构不完全，会造成内存泄漏；如果定义为虚析构函数，删除该指针时就会先调用派生类的析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

### 4.什么情况使用纯虚函数

* 当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；

* 这个方法必须在派生类（derived class）中被实现。

  ```c++
  virtual void print() = 0;
  ```
  
  纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承
  
  包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象。
  
  使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。

### 5.构造函数为什么一般不定义为虚函数

从虚函数是如何调用的角度来分析。

1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，**由于对象还未创建成功，编译器无法知道对象的实际类型**，是类本身还是类的派生类等等

2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。

### 6.计算下面几个类的大小

```C++
class A {};
int main(){
  cout<<sizeof(A)<<endl;// 输出 1;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 1;
  return 0;
}

```

空类的大小是1， 在C\+\+中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。

空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。

```C++
class A { virtual Fun(){} };
int main(){
  cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);
  A a; 
  cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);
  return 0;
}
```

因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br>

```C++
class A { static int a; };
int main(){
  cout<<sizeof(A)<<endl;// 输出 1;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 1;
  return 0;
}
```

静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小

```C++
class A { int a; };
int main(){
  cout<<sizeof(A)<<endl;// 输出 4;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 4;
  return 0;
}
```

```C++
class A { static int a; int b; };;
int main(){
  cout<<sizeof(A)<<endl;// 输出 4;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 4;
  return 0;
}
```

静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节

### 7.多态为什么必须通过引用和指针来实现

根本原因是引用与指针的静态类型与动态类型不同。

**静态类型**是变量声明时的类型或表达式生成的类型，在编译时是已知的；

**动态类型**则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知。

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。

绑定是程序自身彼此关联的过程，确定程序中的操作调用与执行该操作的代码间的关系。例如把一个标示符名和一个存储地址联系在一起的过程。绑定(Binding)是指将**变量**和**函数名**转换为地址的过程。

**静态绑定**，绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。C++中，除虚函数外，其他函数均是静态绑定的。

**动态绑定**，绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。

如果通过一个非引用非指针的表达式调用虚函数时，在编译时就会将调用的版本确定下来，我们可以改变基类对象的值，但不能改变他的类型，因此调用的就是基类中的函数；使用基类的引用或指针调用基类中定义的虚函数时，直到运行时才会确定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。

对非虚函数的调用是在编译时进行绑定的，类似的，通过对象进行的函数调用（虚函数和非虚函数）也是在编译时绑定的。因为对象的类型是确定不变的，它的静态类型和动态类型一致。

[多态与动态绑定](https://www.cnblogs.com/wkfvawl/p/10762600.html)

## 四.封装(类)

### 1.初始化列表

​	成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：

```c++
class A{
	int id;
	string name;
	FaceImage face;
	A(int& inputID,string& inputName,FaceImage& 			inputFace):id(inputID),name(inputName),face(inputFace){} // 成员初始化列表
};
```

​	使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，所以使用成员初始化列表效率会高一些。

​	有三种情况是<font color = "red">必须使用成员初始化列表进行初始化</font>的：

* **常量成员**的初始化，因为常量成员只能初始化不能赋值
* **引用类型**
* **没有默认构造函数的对象**必须使用成员初始化列表的方式进行初始化

### 2.类中的protect的作用

* 说明该成员只能被类和类的友元函数以及派生类访问
* protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private

### 3.struct和class的区别

* struct的默认访问权限是public，class是private

* struct的继承默认是public继承，而class的继承默认是private继承
* class可以用作模板，而struct不能

### 4.友元函数和友元类

https://www.cnblogs.com/zhuguanhao/p/6286145.html

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

**类A要访问类B的成员，在类B中声明类A是B的友元。**

1）友元函数

友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。

```c++
#include <iostream>

using namespace std;

class A
{
public:
    friend void set_show(int x, A &a);      //该函数是友元函数的声明
private:
    int data;
};

void set_show(int x, A &a)  //友元函数定义，为了访问类A中的成员
{
    a.data = x;
    cout << a.data << endl;
}
int main(void)
{
    class A a;

    set_show(1, a);
    
    return 0;

}
```

一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。

2）友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明。

```c++
 #include <iostream>

using namespace std;

class A
{
public:
    friend class C;                         //这是友元类的声明
private:
    int data;
};

class C             //友元类定义，为了访问类A中的成员
{
public:
    void set_show(int x, A &a) { a.data = x; cout<<a.data<<endl;}
};

int main(void)
{
    class A a;
    class C c;

    c.set_show(1, a);
    
    return 0;

}
```

使用友元类时注意： 

(1) 友元关系不能被继承。 

(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 

(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明

### 5.拷贝构造函数相关

[拷贝构造函数详解](https://blog.csdn.net/lwbeyond/article/details/6202256)

####  1) 什么情况下会调用拷贝构造函数（三种情况）

* 对象以值传递的方式传入函数参数 

  >如 ` void func(Dog dog){};`

* 对象以值传递的方式从函数返回

  >如 ` Dog func(){ Dog d; return d;}`

* 对象需要通过另外一个对象进行初始化

####  2) 深拷贝和浅拷贝的区别

**浅拷贝**就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。

**深拷贝**是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。

​	深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。

### 6. 成员函数在内存中的存储方式

* 成员函数的存储

  所有的类成员函数和非成员函数代码都存放在代码区。

  **不论成员函数在类内定义还是在类外定义，成员函数的代码段都用同一种方式存储。成员函数的代码段都不占用对象的存储空间。**

* 类的成员变量的存储

  类的**静态成员变量**在类定义时就已经在全局数据区分配了内存，因而它是**属于类**的。对于**非静态成员变量**，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是**属于对象**的。

* 静态成员函数和非静态成员函数的区别

  **静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区**的，因而可以说它们都是属于类的，但是类为什么只能直接调用静态类成员函数，而非静态类成员函数(即使函数没有参数)只有类对象才能调用呢？原因是**类的非静态类成员函数其实都内含了一个指向类对象的指针型参数(即this指针)，因而只有类对象才能调用(此时this指针有实值)**。

* 类对象如何调用成员函数

  每个非静态成员函数都有一个额外的、隐形的形参this，在调用成员函数时，形参this初始化为调用函数对象的地址。

  ```c++
  void Point3d::translate(const Point3d& pt) {
      x += pt.x;
      y += pt.y;
      z += pt.z;
  }
  
  //事实上x、y、z的存取是经由this指针完成的，其函数参数可以理解为：
  void Point3d::translate(Point3d * const this,const Point3d& pt)
  {
      this -> x += pt.x;
      this -> y += pt.y;
      this -> z += pt.z;
  }
  ```

  不同的对象使用的是同一个函数代码段，它怎么能够分别对不同对象中的数据进行操作呢？原来C++为此专门设立了一个名为this的指针，用来指向不同的对象。

## 五. C++程序构建及编译原理

### 1.程序构建的步骤

* 预处理

  预编译步骤将源代码文件`hello.c`以及相关头文件，如：`stdio.h`等预编译生成一个.i文件。对于C++程序，其源代码文件的扩展名可能是.cpp或.cxx，头文件的扩展名可能是.hpp，预编译生成.ii文件。

  **预编译**主要处理源代码中的以“#”开始的预编译指令，如：“#include”、“#define”等，其主要处理规则如下：

  - 将所有的“#define”删除，并且展开所有的宏定义。
  - 处理所有条件预编译指令，如：“#if”、“#ifdef”、“#else”、“#endif”。
  - 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。该过程是递归进行的，因为被包含的文件可能还包含其他文件。
  - 删除所有的注释“//”和“/ /”。
  - 添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号。
  - 保留所有的#pragma编译器指令，因为编译器须要试用他们。

* 编译——生成汇编代码文件

  **编译**就是把预处理生成的文件进行一系列词法分析、语法分析、语义分析、优化，生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。

* 汇编——**生成,o文件**

  **汇编**就是将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。汇编过程相对于编译比较简单，其没有复杂的语法、语义，也无需做指令优化，只是根据汇编指令和机器指令的对照表进行翻译。

* 链接——**生成可执行文件**

  **链接**主要是将前面步骤生成多个目标文件进行重定位等复杂的操作，从而生成可执行文件。链接可分为静态链接和动态链接。

### 2.编译过程可分为哪些步骤

- **扫描（Scanning）**（又称词法分析）
- **语法分析（Syntax analysis）**
- **语义分析（Semantic Analysis）**
- **源代码优化（Source Code Optimization）**
- **目标代码生成（Target Code Generation）**
- **目标代码优化（Target Code Optimization）**

问题：

1>.o文件是在哪一步生成的  ——编译汇编之后生成

2> 可执行文件是在哪一步生成的——链接之后生成

### 3.动态链接和静态链接的区别，优缺点

* **静态链接：** 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

  缺点：

  1)  空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；

  2)  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

  优点：

​		运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行**速度快**。

* **动态链接**： 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

  优点：

  1)  共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；

  2)  更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

  缺点：

  性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失

### 4.C++的调用惯例（简单一点C++函数调用的压栈过程）

函数的调用过程：

1）从栈空间分配存储空间

2）从实参的存储空间复制值到形参栈空间

3）进行运算

形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。

数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。

## 六. C++11

### 1.智能指针，shared_ptr和unique_ptr如何实现

### 2.shared_ptr引用计数如何实现，为什么导致循环引用

### 3.weak_ptr如何解决shared_ptr的循环引用

### 4.unique_ptr如何实现不允许复制的

### 5.C++的四种强制转换

四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast

[C++的强制类型转换](https://blog.csdn.net/ydar95/article/details/69822540)

* 1）static_cast ：
  用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。

  >特性与要点：
  >
  >1. 它没有运行时类型检查，所以是有安全隐患的。
  >2. 在派生类指针转换到基类指针时(上行转换)，是没有任何问题的，在基类指针转换到派生类指针的时候(下行转换)，会有安全问题。
  >3. static_cast不能转换const，volatile等属性

  ```c++
  /* 常规的使用方法 */
  float f_pi=3.141592f
  int   i_pi=static_cast<int>(f_pi); /// i_pi 的值为 3
  
  /* class 的上下行转换 */
  class Base{
      // something
  };
  class Sub:public Base{
      // something
  }
  
  //  上行 Sub -> Base
  //编译通过，安全
  Sub sub;
  Base *base_ptr = static_cast<Base*>(&sub);  //派生类的指针转化成基类的指针
  
  //  下行 Base -> Sub
  //编译通过，不安全
  Base base;
  Sub *sub_ptr = static_cast<Sub*>(&base); 
  ```

* 2）dynamic_cast：
  用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。
  dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。
  dynamic_cast如果不能转换返回NULL。

  ```c++
  #include<iostream>
  using namespace std;
  
  class Base{
  public:
      Base() {}
      ~Base() {}
      void print() {
          std::cout << "I'm Base" << endl;
      }
  
      virtual void i_am_virtual_foo() {}
  };
  
  class Sub: public Base{
  public:
      Sub() {}
      ~Sub() {}
      void print() {
          std::cout << "I'm Sub" << endl;
      }
  
      virtual void i_am_virtual_foo() {}
  };
  int main() {
      //派生类指针转化成基类指针，正常转化
      cout << "Sub->Base" << endl;
      Sub * sub = new Sub();
      sub->print();
      Base* sub2base = dynamic_cast<Base*>(sub);
      if (sub2base != nullptr) {
          sub2base->print();
      }
      cout << "<sub->base> sub2base val is: " << sub2base << endl;
  
      //基类指针转化成派生类，不能转换，返回nullptr
      cout << endl << "Base->Sub" << endl;
      Base *base = new Base();
      base->print();
      Sub  *base2sub = dynamic_cast<Sub*>(base);
      if (base2sub != nullptr) {
          base2sub->print();
      }
      cout <<"<base->sub> base2sub val is: "<< base2sub << endl;
  
      delete sub;
      delete base;
      return 0;
  }
  /* vs2017 输出为下
  Sub->Base
  I'm Sub
  I'm Base
  <sub->base> sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样
  
  Base->Sub
  I'm Base
  <base->sub> base2sub val is: 00000000   // VS2017的C++编译器,对此类错误的转换赋值为nullptr
  */
  ```

  dynami_cast 在程序运行时对类型转换对*“运行期类型信息”（Runtime type information，RTTI）*进行了检查。
  这个检查主要来自*虚函数(virtual function)*。 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。*因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数*。

* 3）const_cast：
  用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。

  * 常量指针被转化成非常量的指针，并且仍然指向原来的对象；

  * 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

  * const_cast一般用于修改指针。如const char *p形式。

    ```c++
    #include<iostream>
    int main() {
        // 原始数组
        int ary[4] = { 1,2,3,4 };
    
        // 打印数据
        for (int i = 0; i < 4; i++)
            std::cout << ary[i] << "\t";
        std::cout << std::endl;
    
        // 常量化数组指针
        const int*c_ptr = ary;
        //c_ptr[1] = 233;   //error
    
        // 通过const_cast<Ty> 去常量
        int *ptr = const_cast<int*>(c_ptr);
    
        // 修改数据
        for (int i = 0; i < 4; i++)
            ptr[i] += 1;    //pass
    
        // 打印修改后的数据
        for (int i = 0; i < 4; i++)
            std::cout << ary[i] << "\t";
        std::cout << std::endl;
    
        return 0;
    }
    
    /*  out print
        1   2   3   4
        2   3   4   5
    */
    ```

* 4）reinterpret_cast
  几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。通常为操作数的位模式提供较低层次的重新解释，但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！

  ```c++
  #include<iostream>
  #include<cstdint>
  using namespace std;
  int main() {
      int *ptr = new int(233);
      uint32_t ptr_addr = reinterpret_cast<uint32_t>(ptr);
      cout << "ptr 的地址: " << hex << ptr << endl
          << "ptr_addr 的值(hex): " << hex << ptr_addr << endl;
      delete ptr;
      return 0;
  }
  /*
  ptr 的地址: 0061E6D8
  ptr_addr 的值(hex): 0061e6d8
  */
  ```

### 6.lambda表达式：

它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：

```c++
[函数对象参数](操作符重载函数参数)mutable或exception声明->返回值类型{函数体}

//[capture](parameters) -> return-type{body};

void abssort(float* x, unsigned N)
{
	/*
	1.lambda表达式，用于创建匿名函数
	2.[]为lambda引入符
	3.捕获类型的选择：
	 [] // 不捕获任何外部变量
     [=] // 以值的形式捕获所有外部变量
	 [&] // 以引用形式捕获所有外部变量
     [x, &y] // x 以传值形式捕获，y 以引用形式捕获
     [=, &z]// z 以引用形式捕获，其余变量以传值形式捕获
     [&, x] // x 以值的形式捕获，其余变量以引用形式捕获
	4. 返回值类型->return-type可以省略，由语言自动推导，但前提是只有当 lambda 表达式中的语句“足够简单”，才能自动推断返回值类型。
	5. 传值的形式捕获外部变量不允许修改变量的值
	*/
	sort(x, x + N,
		[](float a, float b) {return std::abs(a) < std::abs(b); });	
}

int main()
{
	float f0 = 1.0;
	cout << [=](float f) mutable {return f0 += abs(f); }(-3.5);//mutable使得f0的值可以被修改，但只是改变了内部的f0的值，外部依然为1.0
	cout << '\n' << f0 << '\n';
	return 0;
}
//运行结果：4.5   1

//引入lambda表达式的原因：
 1）可以定义匿名函数；
 2）编译器会把其转成函数对象；为什么以前STL中的ptr_fun()这个函数对象不能用？（ptr_fun()就是把一个自然函数转成函数对象的）原因是，ptr_fun() 的局限是其接收的自然函数只能有1或2个参数。
 3）”闭包”，限制了别人的访问，更私有；
```

## 七.其他

### 1.C++和C的区别

* C是面向过程的语言，C\+\+是面向对象的语言，C\+\+有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。
* C和C\+\+内存管理的方法不一样，C使用malloc/free，C\+\+除此之外还用new/delete
* C\+\+中还有函数重载和引用等概念，C中没有

### 2. C++、Java的联系与区别，

包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）

包括但不限于：

* C\+\+ 和Java都是面向对象的语言，C\+\+是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C\+\+ 高。
* C\+\+的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法
* C\+\+有指针，Java没有指针，只有引用
* JAVA和C\+\+都有构造函数，但是C\+\+有析构函数但是Java没有

### 3. C++和python的区别

包括但不限于：

1. python是一种脚本语言，是解释执行的，而C\+\+是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C\+\+高。
2. python使用缩进来区分不同的代码块，C\+\+使用花括号来区分
3. C\+\+中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等
4. python的库函数比C\+\+的多，调用起来很方便

### 4.链表与数组的区别

* 数组的长度是固定的，不能适应数据动态增减的情况；链表动态地进行内存分配，可适应数据动态地增减的情况，且可以方便地插入、删除数据项。
* 静态数组从栈中分配空间，对于程序员方便快速,但自由度小；链表从堆中分配空间，自由度大但申请管理比较麻烦；
* 数组可以随机存取，但插入删除效率较低，需要移动其他元素；链表不支持随机存取，插入删除效率高；
* 链表不存在越界问题，在内存中不连续；数组是连续的一块内存空间

### 5.定义和声明的区别

* 声明是告诉编译器变量的类型和名字，不会为变量分配空间

* 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次

## 八. 设计模式

### 1.编程实现单例模式

```c++
class Singleton{
  private:
    static Singleton* instance;
    Singleton(){
      // initialize
    }
  public:
    static Singleton* getInstance(){
      if(instance==nullptr) instance=new Singleton();
      return instance;
    }
};
```

### 2.设计模式的基本原则

### 

## 九. 开放式问题

### 1.对1T数据进行排序

### 7.二分查找时间复杂度的计算过程

### 8.数据库的事务、索引

